====== Debugging ======

We provide a [[https://osdn.net/projects/darling/storage/apps/lldb.tar.bz2|build of LLDB]] that is known to work under Darling. It is built from vanilla sources, i.e. without any modifications.

That doesn't mean it works //reliably//. Fully supporting a debugger is a complex task, so LLDB is known to be buggy under Darling.

===== Troubleshooting LLDB =====

If you want to troubleshoot a problem with how LLDB runs under Darling, you need to make ''debugserver'' produce a log file.

If running ''debugserver'' separately, add ''-l targetfile''. If using LLDB directly (which spawns ''debugserver'' as a subprocess automatically), pass an additional environment variable to LLDB:

<code>LLDB_DEBUGSERVER_LOG_FILE=somelogfile.txt</code>

===== External DebugServer =====

If you're having trouble using LLDB normally, you may get luckier by running the ''debugserver'' separately.

In one terminal, start the ''debugserver'':

<code>./debugserver 127.0.0.1:12345 /bin/bash</code>

In another terminal, connect to the server in LLDB:

<code>
$ ./lldb
(lldb) platform select remote-macosx
  Platform: remote-macosx
 Connected: no
(lldb) process connect connect://127.0.0.1:12345
</code>

Please note that environment variables may be missing by default, if used like this.

===== How it Works =====

Debugging support in Darling makes use of what we call "cooperative debugging". It means the code in the debuggee is aware it's being debugged and actively assists the process. In Darling, this role is taken on mainly by [[https://github.com/darlinghq/darling/blob/master/src/kernel/emulation/linux/signal/sigexc.c|sigexc.c]] in ''libsystem_kernel.dylib'', so no application modifications are necessary.

MacOS debuggers use a combination of BSD-like and Mach APIs to control and inspect the debuggee.

To emulate the macOS behavior, Darling makes use of POSIX real-time signals to invoke actions in the cooperative debugging code.

^ Operation ^ macOS ^ Linux ^ Darling implementation ^
| Attach to debuggee | ''ptrace(PT_ATTACHEXC)'' \\ Causes the kernel to redirect all signals (aka exceptions) to the Mach "exception port" of the process. Only debuggee termination is notified via ''wait()''. | ''ptrace(PTRACE_ATTACH)'' \\ Signals sent to the debuggee and the debuggee termination event are received in the debugger via ''wait()''. | Notify the LKM that we will be tracing the process. Send a RT signal to the debuggee to notify it of the situation. The debuggee sets up handlers to handle all signals and forward them to the exception port. |
| Examine registers | ''thread_get_state(X86_THREAD_STATE)'' | ''ptrace(PTRACE_GETREGS)'' | Upon receiving a signal, the debuggee reads its own register state and passes it to the kernel via ''thread_set_state()''. |
| Pausing the debuggee | ''kill(SIGSTOP)'' | ''kill(SIGSTOP)'' or ''ptrace(PTRACE_INTERRUPT)'' | Send a RT signal to the debuggee that it should act as if SIGSTOP were sent to the process. We cannot send a real SIGSTOP, because then the debuggee couldn't provide/update register state to the debugger etc. |
| Change signal delivery | ''ptrace(PT_THUPDATE)'' | ''ptrace(PTRACE_rest)'' | Send a RT signal to the debuggee to inform it what it should do with the signal (ignore, pass it to the application etc.) |
| Set memory watchpoints | ''thread_set_state(X86_DEBUG_STATE)'' | ''ptrace(PTRACE_POKEUSER)'' | Implement the effects of ''PTRACE_POKEUSER'' in the LKM. |